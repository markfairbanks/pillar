---
title: "Controlling display of numbers"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{Controlling display of numbers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Tibbles print numbers with three significant digits by default, switching to scientific notation if the available space is too small.
Underlines are used to highlight groups of three digits.
This display works for many, but not for all use cases.

```{r}
library(pillar)
```

## The `num()` constructor

```{r}
#' @export
num <- function(x, sigfig = NULL, digits = NULL, 
                label = NULL, scale = NULL, notation = NULL) {
  
  stopifnot(is.numeric(x))
  
  # FIXME: math and arith should also work for integers
  x <- as.numeric(x)

  # FIXME: can't use set_num_opts()
  vctrs::new_vctr(
    x,
    pillar_sigfig = sigfig,
    pillar_digits = digits,
    pillar_label = label,
    pillar_scale = scale,
    pillar_notation = notation,
    class = "tibble_num",
    inherit_base_type = TRUE
  )
}

#' @importFrom pillar pillar_shaft
#' @export
pillar_shaft.tibble_num <- function(x, ...) {
  # still seems necessary
  pillar_shaft(unclass(x))
}

library(vctrs)

#' @export
vec_ptype_full.tibble_num <- function(x, ...) {
  notation <- attr(x, "notation")
  if (is.null(notation)) {
    class <- "tibble_num"
  } else {
    class <- paste0("tibble_num(", notation, ")")
  }
  
  sigfig <- attr(x, "sigfig")
  digits <- attr(x, "digits")
  label <- attr(x, "label")
  notation <- attr(x, "notation")
  
  if (!is.null(digits)) {
    out <- paste0(class, ":.", digits)
  } else if (is.null(sigfig)) {
    out <- class
  } else {
    out <- paste0(class, ":", sigfig)
  }

  if (!is.null(label)) {
    out <- paste0(out, "{", label, "}")
  }

  out
}

#' @export
vec_ptype_abbr.tibble_num <- function(x, ...) {
  notation <- attr(x, "pillar_notation")
  if (is.null(notation)) {
    notation <- "num"
  }
  
  sigfig <- attr(x, "pillar_sigfig")
  digits <- attr(x, "pillar_digits")
  
  if (is.null(digits)) {
    if (is.null(sigfig)) {
      notation
    } else {
      paste0(notation, ":", sigfig)
    }
  } else {
    paste0(notation, ":.", digits)
  }
}
```

## Showing `num`

```{r}
library(tibble)
```


### Significant figures

```{r}
tibble(
  x3 = num(9:11 * 100 + 0.5, 3),
  x4 = num(9:11 * 100 + 0.5, 4),
  x5 = num(9:11 * 100 + 0.5, 5),
)
```


### Decimal digits

```{r}
tibble(
  x0 = num(9:11 * 100 + 0.5, digits = 0),
  x1 = num(9:11 * 100 + 0.5, digits = 1),
  x2 = num(9:11 * 100 + 0.5, digits = 2),
)
```


### Currency

```{r}
tibble(
  usd = num(9:11 * 100 + 0.5, digits = 2, label = "USD"),
  gbp = num(9:11 * 100 + 0.5, digits = 2, label = "£"),
  chf = num(9:11 * 100 + 0.5, digits = 2, label = "SFr")
)
```


### Percentage

```{r}
tibble(
  small  = num(9:11 / 1000 + 0.00005, label = "%", scale = 100),
  medium = num(9:11 /  100 + 0.0005 , label = "%", scale = 100),
  large  = num(9:11 /   10 + 0.005  , label = "%", scale = 100)
)
```


### Notation

```{r}
tibble(
  sci  = num(10^(-13:6), notation = "sci"),
  eng  = num(10^(-13:6), notation = "eng"),
  dec  = num(10^(-13:6), notation = "dec")
)
```


### Fixed exponent

```{r}
tibble(
  scifix  = num(10^(-13:6) * 123, notation = "scifix"),
  engfix  = num(10^(-13:6) * 123, notation = "engfix")
)
```

## Computing on `num`

```{r}
format.tibble_num <- function(x, ...) {
  shaft <- pillar_shaft(x)
  out <- format(shaft, width = get_width(shaft))
  attributes(out) <- NULL
  out
}
```

### Arithmetics

```{r}
vec_arith.tibble_num <- function(op, x, y, ...) {
  UseMethod("vec_arith.tibble_num", y)
}
vec_arith.tibble_num.default <- function(op, x, y, ...) {
  stopifnot(is.numeric(x), is.numeric(y))
  out <- vec_arith_base(op, x, y)
  
  if (inherits(x, "tibble_num")) {
    vec_restore(out, x)
  } else {
    vec_restore(out, y)
  }
}
vec_arith.tibble_num.MISSING <- function(op, x, y, ...) {
  stopifnot(is.numeric(x))
  # FIXME
  out <- vec_arith_base(op, 0, x)
  
  vec_restore(out, x)
}

vec_arith.numeric.tibble_num <- vec_arith.tibble_num.default
```

```{r}
num(1) + 2
1 + num(2)
1L + num(2)
num(3.23456, sigfig = 4) - num(2)
num(3, digits = 2) * num(4, sigfig = 2)
```

```{r}
-num(2)
```

### Mathematics

```{r}
vec_math.tibble_num <- function(op, x, ...) {
  stopifnot(is.numeric(x))
  out <- vec_math_base(op, x)
  
  vec_restore(out, x)
}
```

```{r}
min(num(1:3, label = "€"))
mean(num(1:3, notation = "eng"))
sin(num(1:3, label = "%", scale = 100))
```

## Integrating with other classes

### units

```{r}
set_num_opts <- function(x, sigfig = NULL, digits = NULL, 
                         label = NULL, scale = NULL, notation = NULL) {
  attr(x, "pillar_sigfig") <- sigfig
  attr(x, "pillar_digits") <- digits
  attr(x, "pillar_label") <- label
  attr(x, "pillar_scale") <- scale
  attr(x, "pillar_notation") <- notation
  x
}

library(units)

pillar(set_num_opts(set_units(1:3, m), notation = "sci") + set_units(1:3, km))
pillar(set_num_opts(set_units(1:3, km), digits = 2) + set_units(1:3, m))

# FIXME: subsetting needs to preserve pillar attributes
set_num_opts(set_units(1:3, m) + set_units(1:3, km), notation = "sci")
set_num_opts(set_units(1:3, m) + set_units(1:3, km), notation = "sci")[1:3]
```
